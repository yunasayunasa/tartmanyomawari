Odyssey Engine v5.10 - ユーザーマニュアル (最終確定・完成版)
1. はじめに：これは、あなたの「世界」のためのエンジンです
Odyssey Engineへようこそ。
このエンジンは、単なるツールではありません。私達が共にたどり着いた**「安定した世界の器」**です。Phaser 3が持つパワフルな表現力と、ティラノスクリプトのような直感的な記述法。この二つを融合させ、ノベルゲームと他のジャンルを組み合わせた「ハイブリッドゲーム」を、誰もが創造できる世界を目指して生まれ変わりました。
このマニュアルは、その旅路に立つあなたのための、唯一無二の羅針盤です。

2. エンジンの設計思想：なぜ、こうなっているのか
このエンジンは、いくつかの強力な柱によって支えられています。

中央集権的なシーン管理 (SystemScene): シーン遷移という不安定になりがちな処理を、司令塔であるSystemSceneに一任。あなたは「このシーンへ行け」と命令するだけで、エンジンが安全な遷移を保証します。
イベント駆動の状態管理 (StateManager): HPが減る、フラグが立つ。そういったゲーム内の「出来事」は、すべてStateManagerという唯一の状態管理者が記録します。UIやゲームロジックは、その変化を「聞く」だけで自動的に更新されます。
【v3.0】データ駆動によるシーン構築: アクションやパズルなど、ノベル以外のゲームシーンは、.jsonファイルによってその**初期レイアウト（オブジェクトの配置、物理特性など）**を定義します。これにより、コードを触ることなく、ステージの設計をデータとして管理・編集できます。
【v3.0】インゲーム・エディタによる開発支援: デバッグモードで起動することで、ゲーム画面そのものが統合開発環境 (IDE) となります。アセットの配置から、オブジェクトのプロパティ調整、レイアウトデータの出力までを、視覚的かつ直感的に行うことができます。
3. ゲーム制作の2つのモード
Odyssey Engine v3.0でのゲーム制作は、主に2つのモードで行われます。

3.1. シナリオモード (GameScene / .ksファイル)
伝統的なノベルゲームのパートです。物語、キャラクターの会話、基本的な演出は、これまで通り.ksという拡張子のテキストファイルに記述します。

3. シナリオ入門：物語を記述する (.ksファイル)
ゲームの物語、演出、キャラクターの動きは、すべて.ksという拡張子のテキストファイルに記述します。

3.1. シナリオの基本構造
要素	書き方	役割
テキスト	テキストをそのまま記述	メッセージウィンドウに文章を表示（地の文）
セリフ	キャラクター名: テキスト	話者付きでセリフを表示
タグ	[タグ名 パラメータ=値]	演出、分岐、シーン遷移などの特殊な命令
ラベル	*ラベル名	[jump]や[link]のジャンプ先となる目印
コメント	; で始まる行	実行時に無視されるメモ
アセット宣言	@asset type=image key=... path=...	このシナリオで使うアセットを、シナリオ開始時に動的に読み込む
シナリオの例:

Generated text
; これはゲームに影響しないコメントです

; ▼ このシナリオで使うアセットを宣言します
@asset type=image key=bg_school path=backgrounds/school_day.png
@asset type=image key=yuko_smile path=characters/yuko_smile.png

*start
; 演出タグは連続で実行され、クリックを待ちません
[bg storage=bg_school]
[chara_show name=yuko storage=yuko_smile pos=center]

; テキストも、[p]タグが来るまでは止まりません
yuko:「こんにちは、世界！」
yuko:「これがOdyssey Engineよ！」

; [p]タグで、初めてクリックを待って改ページします
[p]

; [br]タグは、同じウィンドウの中で改行します
yuko:「とっても簡単でしょ？[br]さあ、始めましょう！」
[p]
[s]

content_copy

download
Use code with caution.
Text
3.2. テキストと改ページ・改行のルール
Odyssey Engineのテキスト制御は、非常にシンプルで強力なルールに基づいています。

タグ	役割	実行後の状態
[br]	文中改行 (Break)	同じメッセージ内で改行。シナリオは停止せず、処理を続行。
[p]	改ページ (Page Break / Pause)	クリック待ちになる。クリックされるとウィンドウがクリアされ、次の行へ。
(テキスト行)	文字表示	メッセージウィンドウに文字を表示するだけ。シナリオは停止しない。
このルールにより、**「演出タグを連続で実行し、最後に[p]で待つ」**といった、テンポの良いシナリオ記述が可能になります。

4. 変数について
Odyssey Engineには2種類の変数があり、ゲームの状態を記憶します。

ゲーム変数 (f.): 好感度、フラグ、所持金など、セーブデータに含まれる変数。
例: f.love_meter, f.item_get_flag
システム変数 (sf.): 既読管理、各種設定など、セーブデータとは別にゲーム全体で共有される変数。
例: sf.config_text_speed
変数の操作は、主に[eval]タグと[if]タグで行います。変数の値をテキスト中に表示するには &f.変数名 のように記述します。

5. タグ・リファレンス
タグはエンジンの力の源です。パラメータは 属性=値 の形式で、半角スペースで区切って複数指定できます。値にスペースを含みたい場合は " (ダブルクォート) で囲ってください。

カテゴリ: フロー制御
物語の流れを自在にコントロールします。

<details>
<summary><strong><code>[p]</code>, <code>[link]</code>, <code>[r]</code>, <code>[s]</code> - 待機と選択肢</strong></summary>
[p]: 改ページ（クリック待ち）
シナリオの進行を一時停止し、プレイヤーのクリックを待ちます。クリックされると、メッセージウィンドウがクリアされ、次の行の処理に進みます。テキストの区切りで最もよく使うタグです。
[link], [r], [s]: 選択肢の基本セット
この3つのタグはセットで使います。プレイヤーに選択を促すためのフローです。
[link text="ボタンの文字" target="*ジャンプ先"]: 選択肢を定義します。この時点では画面に表示されません。
[r] (Render): [link]で定義された選択肢を画面に表示します。
[s] (Stop): シナリオの進行を停止し、プレイヤーが選択肢をクリックするのを待ちます。
使用例:
Generated text
yuko:「今日はどこへ行く？」[p]

; 選択肢を定義
[link text="公園" target="*park"]
[link text="図書館" target="*library"]

; [r]で選択肢を表示する
[r]
; [s]でプレイヤーの選択を待つ。必須！
[s]

*park
; 公園のシナリオ...
[jump target="*common_route"]

content_copy

download
Use code with caution.
Text
</details>
<details>
<summary><strong><code>[if]</code>, <code>[jump]</code>, <code>[call]</code> - 分岐と遷移</strong></summary>
[if], [elsif], [else], [endif]: 条件分岐
変数の値に応じて、シナリオの実行内容を分岐させます。
[if exp="条件式"]: 条件式が真(true)の場合に実行。
条件式はJavaScriptの構文です。例: f.love >= 10, f.flag === true
[endif]で分岐の終わりを必ず示してください。
[jump]: ジャンプ
戻ってくることを想定しない、一方通行の移動です。現在のシナリオ実行を終了し、指定された場所へ移動します。
target="*ラベル名": 同じファイル内のラベルへ移動。
storage="SceneKey": 別のPhaserシーン（バトル、パズルなど）へ遷移。
params="{...}": storage指定時、遷移先のシーンに変数を渡せます。
[call], [return]: サブルーチン
一時的に別の場所の処理を呼び出し、終わったら元の場所に戻ってくる機能です。共通のイベントなどを部品化するのに便利です。
[call]で target や storage を指定して呼び出し、サブルーチンの最後に[return]を記述します。
</details>
カテゴリ: キャラクター・画像
画面を華やかに彩ります。

<details>
<summary><strong>主要な画像操作タグ</strong></summary>
[chara_show]: キャラクターを表示します。
name (必須): キャラクターの管理名。セリフの話者名と一致させます。
storage (必須): アセットの画像キー。
pos: left, center, rightから選択。x, yでの座標指定も可能。
time: フェードイン時間（ミリ秒）。
nowait="true": アニメーションの完了を待たずに次の処理へ進みます。
[chara_mod]: 表示中のキャラクターの画像を差し替えます。（表情差分など）
name (必須): 対象キャラクターのname。
storage (必須): 新しい画像キー。
time: クロスフェードの時間（ミリ秒）。
[chara_hide]: キャラクターを消去します。
name (必須): 対象キャラクターのname。
time: フェードアウト時間（ミリ秒）。
[bg]: 背景を表示します。
storage (必須): 画像キー。
time: フェードイン/クロスフェードの時間（ミリ秒）。
[image] / [freeimage]: CGなどの前景画像を表示・消去します。chara_showと似たパラメータが使えます。
</details>
カテゴリ: 演出・音声
ゲーム体験を豊かにします。

<details>
<summary><strong>主要な演出・音声タグ</strong></summary>
[shake]: 画面を揺らします。
time (必須): 揺れる時間（ミリ秒）。
power: 揺れの強さ。
[flash]: 画面を特定の色で一瞬光らせます。
color: 0xffffff（白）のような16進数カラーコード。
time: フラッシュの時間。
[playbgm] / [stopbgm]: BGMの再生と停止。
storage (必須): BGMのキー。
loop: true (デフォルト) or false。
[stopbgm]では time でフェードアウト時間を指定できます。
[playse]: 効果音を再生します。
</details>
カテゴリ: 変数操作・その他
<details>
<summary><strong>主要なユーティリティタグ</strong></summary>
[eval]: ゲーム変数(f.)やシステム変数(sf.)の値を直接操作する、非常に強力なタグです。
exp (必須): 実行するJavaScript式を記述します。
例: [eval exp="f.love = f.love + 10"]
[wait]: 指定時間、処理を待ちます。
time (必須): 待機する時間（ミリ秒）。1000で1秒。
[hidewindow] / [showwindow]: メッセージウィンドウを非表示/表示します。
</details>
6. ゲームの拡張（プログラマー向け）
このセクションは、エンジンに新しい機能を追加したい開発者向けの技術情報です。

6.1. 新規タグの追加
src/handlers/にハンドラファイル (new_tag.jsなど) を作成します。
src/handlers/index.jsを開き、作成したファイルをimportし、tagHandlersオブジェクトに1行追加します。
これだけで、エンジンは新しいタグを自動的に認識します。GameScene.jsを触る必要はありません。
6.2. ⭐【最重要】新規ゲームシーン開発の規約⭐
Odyssey Engineで、ノベルパートから遷移する新しいゲームシーン（アクション、パズルなど）を作る際は、以下のルールを必ず守ってください。これは、エンジン全体の安定性を保つための契約です。
【全ての新規シーンに共通の5ヶ条】
create()の最後にscene-readyを発行する
シーンの準備がすべて完了した最後に、必ずthis.events.emit('scene-ready');を記述します。これがSystemSceneへの「準備完了」の合図です。
BGMはcreate()で再生する
シーンが始まったら、this.soundManager.playBgm('曲名');でBGMの再生を「命令」するだけです。SoundManagerが前の曲を賢く止めてくれます。
ノベルシーンへの復帰はSystemSceneに依頼する
シーンを終了する際は、必ずthis.scene.get('SystemScene').events.emit('return-to-novel', ...)を発行します。自身のstop()は絶対に呼ばないでください。
shutdown()で後片付けをする
shutdown()メソッドを実装し、そのシーンのcreate()で生成したタイマー (this.time.addEvent) やイベントリスナー (this.events.on) は、必ずここで破棄・解除してください。
HUDは操作しない
シーンの中からHPバーを直接操作しようとしないでください。代わりにthis.stateManager.setF('player_hp', 50);のように状態変数を変更します。UIの更新はUISceneとHUD自身が自動的に行います。

第1条：自己申告の原則 (The Principle of Self-Declaration)
UIコンポーネントは、自身が依存するゲーム変数(f.)を、static dependenciesプロパティとして必ずクラス内に明記しなければならない。これにより、エンジンは起動時に依存関係を自動的に解決し、watchリストを構築する。

記述例 (HpBar.js):

code
JavaScript
export default class HpBar extends Phaser.GameObjects.Container {
    // このクラスは f.player_hp と f.player_max_hp の変化を監視することを宣言する
    static dependencies = ['player_hp', 'player_max_hp'];

    // ... constructor ...
}
この申告により、あなたはuiRegistryファイルにwatchプロパティを手で記述する手間から解放される。

第2条：更新メソッドの実装義務 (The Obligation to Implement updateValue)
dependenciesを申告したUIコンポーネントは、updateValue(state)という名前のpublicメソッドを必ず実装しなければならない。このメソッドは、UISceneから呼び出される唯一の公式な窓口である。

仕様:

引数 state: StateManagerが保持する現在のゲーム変数オブジェクト (f) 全体が渡される。
責務: stateオブジェクトの中から、dependenciesで申告したキー（例: state.player_hp）を自身で取り出し、自身の表示（バーの長さ、テキストなど）を更新する。
実装例 (HpBar.js):

code
JavaScript
updateValue(state) {
        const currentHp = state.player_hp || 0;
        const maxHp = state.player_max_hp || 100;

        // ... この値を使ってバーの幅やテキストを更新する処理 ...
    }
第3条：StateManagerへの非干渉 (Non-Interference with StateManager)
UIコンポーネントは、StateManagerの状態を直接購読してはならない (stateManager.on(...)の禁止)。状態変更の検知と通知は、GameSceneとUISceneから成る中央管理システムが一括して行う。コンポーネントの役割は、updateValueメソッドを通じて命令を受け取り、自身の見た目を更新することに限定される。

これにより、イベントリスナーの登録漏れや解除忘れによるメモリリークを構造的に防止し、データの流れを常に一方向（StateManager → UIScene → Component）に保つ。
【データ駆動シーンのための追加規約】
BaseGameSceneを継承する
新しいデータ駆動シーンは、import BaseGameScene from './BaseGameScene.js'; を行い、export default class YourScene extends BaseGameScene としてクラスを定義します。これにより、シーンはエディタ連携とデータ駆動の全ての恩恵を自動的に受け継ぎます。
createでinitSceneWithDataを呼ぶ
create()の中でthis.initSceneWithData()を呼び出すことで、対応する.jsonファイル（例: YourScene.json）が自動で読み込まれ、シーンが構築されます。
オブジェクトの追加はaddObjectFromEditorを実装する
エディタの「追加ボタン」に応答するために、このメソッドをオーバーライドしてください。親クラス（BaseGameScene）の力を借りることで、安全なオブジェクト生成とエディタへの登録が保証されます。
6.3. インゲーム・エディタの使い方
URLの末尾に ?debug=true&edit を付けてゲームを起動すると、IDEモードになります。
アセット・ブラウザ:
利用可能な画像アセットを一覧表示します。アセットを選択し、**「Add Selected Asset to Scene」**ボタンを押すことで、現在アクティブなデータ駆動シーンにオブジェクトを追加できます。
プロパティパネル:
シーン上のオブジェクトを選択すると、そのプロパティ（Name, Transform, Physics）をリアルタイムに編集できます。
Export Layout: 編集中のシーンの現在のレイアウトを、対応する.jsonファイル形式でクリップボードにコピーします。コピーした内容を、assets/data/scenes/フォルダ内の対応するJSONファイルに貼り付けて保存することで、変更が永続化されます。
Delete Object: 選択中のオブジェクトをシーンから完全に削除します。

6.3. 動的アセットロード (@asset)
大規模なゲームでは、最初にすべてのアセットを読み込むと起動が遅くなります。@assetを使うと、そのシナリオが必要とするアセットだけを、シナリオ開始直前に自動で読み込ませることができます。

書式: @asset type="種類" key="管理キー" path="ファイルパス"
配置場所: シナリオファイルの先頭（ラベルや地の文より前）に記述してください。

** 【重要！】** IDEモード (データ駆動シーン / インゲーム・エディタ)
アクション、パズル、探索など、インタラクティブなゲームプレイ部分を構築するための新しいモードです。ここでは、コードやシナリオの代わりに、ゲーム画面上で直接オブジェクトを配置し、設定を調整していきます。

** 【重要！】**新規ゲームシーンの作り方
「JumpScene.js は、BaseGameScene を継承したお手本です。新しいゲームシーンを作る際は、この JumpScene.js をコピーして、クラス名を変更することから始めましょう。」

** 【重要！】**エディタモードの起動方法
ゲームのURLの末尾に ?debug=true を付けて起動します。

レイヤーパネル (Layers)
シーンを「前景(Foreground)」「ゲームプレイ(Gameplay)」「背景(Background)」などの層に分けて管理します。
👁️アイコンでレイヤーの表示/非表示、🔒アイコンでレイヤー上のオブジェクトの選択をロックできます。
オブジェクトは、プロパティパネルで所属するレイヤーを変更できます。
アセットブラウザ (Asset Browser)
ゲームに読み込まれている全てのアセット（画像、プレハブなど）を一覧表示します。
アセットを選択し、**「選択したアセットを追加」**ボタンを押すと、現在アクティブなレイヤーの中央に新しいオブジェクトとして追加されます。
プロパティパネル (Properties)
シーン上のオブジェクトをクリックして選択すると、そのオブジェクトの詳細なプロパティが表示され、リアルタイムに編集できます。
Export Layout: シーンの現在の状態（全オブジェクトの配置、プロパティ、レイヤー情報）を.json形式でクリップボードにコピーします。これをassets/data/scenes/フォルダ内の対応するJSONファイルに貼り付けることで、変更が保存されます。
Name: オブジェクトの固有の名前です。VSLタグからtargetとして指定する際に使います。必ずユニークな名前を付けてください。
Group: オブジェクトが所属する「チーム名」です。イベントの対象をグループで指定する際に使います（後述）。
Transform: 位置(x, y)、拡大率(scale)、角度(angle)、透明度(alpha)、表示順(depth)など、見た目に関する設定です。
物理ボディ (Physics): オブジェクトに物理的な実体を与えるための設定です。

6. オブジェクトの「正体」を決める：グループと物理の大切な話
Odyssey Engineでは、シーンに置かれたすべてのオブジェクトに、2つの大切な「正体」を与えることができます。それは**「グループ（仲間）」と「物理（カタさ）」**です。この2つを理解すると、あなたのゲームの世界はもっと豊かになります。

6.1. オブジェクトグループ：誰の「仲間」なのか？
group（グループ）は、オブジェクトに付ける**「あだな」や「チーム名」**のようなものです。

目的:
エディタで、同じ仲間のオブジェクトをまとめて選択・移動するため。（床タイルをダブルタップで全部選択するなど）
イベントエディタで、**「誰と出会ったら、何が起きるか」**という物語のルールを作るため。
考え方:
「このコインは『coin』という仲間」
「この敵スライムは『enemies』というチーム」
「このドアは『exit_door』という役割」
設定場所: プロパティパネルのGroup入力欄
例：「コインに触れたらスコアが100点アップする」イベントを作る

コインのオブジェクトを選択し、Group入力欄に coin と名付けます。
プレイヤーのオブジェクトを選択し、イベントエディタを開きます。
「イベントを追加」し、以下のように設定します。
トリガー: onOverlap_Start（触れた瞬間）
相手のグループ: coin（"coin"という仲間に触れたら）
アクション: [set_data name=score value="f.score + 100"][destroy target=other]（スコアを100点増やして、触れた相手（コイン）を消す）
このように、groupは**ゲームの物語やルールを作るための、とても大切な「名前」**なのです。

6.2. 物理設定：どれくらい「カタイ」のか？
物理パネルにある設定は、オブジェクトの**「カタさ」や「世界の法則への従い方」**を決めます。これは、物理エンジンという、世界の法則を計算してくれる専門家への指示書のようなものです。

目的:
キャラクターが床の上に乗れるか、壁を通り抜けられないようにするため。
弾が敵には当たるけれど、アイテムはすり抜ける、といった細かいルールを作るため。
考え方:
「この床タイルは、カベと同じくらいカタイ存在」
「このコインは、プレイヤーが触れられるように、フワフワした存在」
「このオバケは、カベをすり抜ける特別な存在」
設定場所: プロパティパネルの物理ボディセクション
2つの大切な物理設定
Category (カテゴリ):
これは、オブジェクトの**「種族」**のようなものです。「あなたはプレイヤー族ですよ」「あなたはカベ族ですよ」と、そのオブジェクトの物理的な正体を決めます。
Collides With (衝突する相手):
これは、そのオブジェクトが**「どの種族とぶつかるか」**を決める設定です。たくさんのチェックボックスが並んでおり、ぶつかってほしい相手の種族にチェックを入れていくだけです。
例：「プレイヤー」オブジェクトの物理設定

プレイヤーを選択し、物理パネルを開きます。
Categoryのドロップダウンからplayerを選びます。（これで彼の種族はplayerになりました）
Collides Withの項目で、wall（カベ）、enemy（敵）、item（アイテム）の3つにチェックを入れます。（これで彼は、カベと敵とアイテムにぶつかるようになります）
例：「プレイヤーの弾」オブジェクトの物理設定

弾を選択し、物理パネルを開きます。
Categoryからplayer_bulletを選びます。
Collides Withで、wall（カベ）とenemy（敵）だけにチェックを入れます。（これで弾は、アイテムをすり抜け、プレイヤー自身にも当たらなくなります）
まとめ：2つの「正体」の使い分け
設定項目	何を決めるか？	一言でいうと	ユースケースの例
オブジェクトグループ	誰の仲間か？	イベントの宛名	coin グループに触れたら、スコアが上がる
物理カテゴリ	どんなカタさか？	衝突のルール	player は wall とは衝突するが、item はすり抜ける

この2つを使いこなせば、「enemies（敵）グループのオブジェクトは、player_bullet（プレイヤーの弾）カテゴリのオブジェクトと衝突し、衝突したら[destroy target=self]（自爆する）イベントが起きる」といった、豊かでインタラクティブな世界を、あなたの手で創造することができます。

7. UIを「生きた」ものにする：コンポーネントシステム入門
これまでのUIは、いわば美しい「絵」でした。しかし、Odyssey Engineの真の力は、UIを単なる絵から、ゲーム世界の出来事にリアルタイムで反応する**「生きた窓」**へと変えることにあります。

それを実現するのがコンポーネントシステムです。

コンポーネントとは、「機能」だけを持つ、目に見えない小さな部品です。エディタ上で、UIオブジェクト（画像やテキスト）にこれらの部品を組み合わせ（アタッチし）ていくことで、プログラミングを一切することなく、HPバーやスコア表示のような動的なUIを自由に作成できます。

7.1. 基本的な考え方：「器」と「神経」と「筋肉」
動的なUIは、3種類の要素の組み合わせで考えます。

器 (GameObject): 見た目そのものです。アセットブラウザから追加した画像やテキストがこれにあたります。
神経 (WatchVariableComponent): ゲーム内の変数を監視し、変化があったら「値が変わったよ！」という信号（イベント）を発信する、目に見えない部品です。
筋肉/声 (DisplayComponent): 神経からの信号を受け取り、器の見た目（幅、テキストなど）を実際に変化させる部品です。
この3つをエディタで組み合わせることで、UIは命を吹き込まれます。

7.2. コンポーネント・リファレンス
プロパティパネルの「Component」セクションから、UIオブジェクトに以下のコンポーネントをアタッチできます。

<h4><code>[WatchVariableComponent]</code> - 神経</h4>
<p>UIに、特定のゲーム変数を監視させるための、最も重要なコンポーネントです。これ単体では見た目は何も変わりませんが、他の表示系コンポーネントと連携するための「神経」として機能します。</p>
<p>アタッチすると、以下のパラメータを編集できます。</p>
<ul>
<li><strong>監視する変数 (f.)</strong> (必須): どのゲーム変数の変化を監視するかを指定します。必ず<code>f.</code>から始まる形式で記述してください。
<ul>
<li>例: <code>f.player_hp</code>, <code>f.score</code>, <code>f.amunition_count</code></li>
</ul>
</li>
</ul>
<p><strong>注意:</strong> 指定した変数（例: <code>f.player_hp</code>）が存在しない、または一度も値が設定されていない場合、このコンポーネントは信号を発信しません。エラーにはなりませんが、UIは変化しないのでご注意ください。</p>
<h4><code>[BarDisplayComponent]</code> - 筋肉（バー表示）</h4>
<p>主に画像オブジェクトにアタッチし、HPバーや経験値バーのように機能させます。神経（<code>WatchVariableComponent</code>）から「値が変わった」という信号を受け取ると、自身の横幅のスケール（<code>scaleX</code>）を、最大値に対する割合に応じて自動で変更します。</p>
<p><strong>前提条件:</strong> このコンポーネントを機能させるには、同じオブジェクトに<code>WatchVariableComponent</code>もアタッチしておく必要があります。</p>
<p>アタッチすると、以下のパラメータを編集できます。</p>
<ul>
<li><strong>最大値の変数 (f.)</strong> (必須): バーが満タン（100%）の時の値を、どのゲーム変数から取得するか指定します。
<ul>
<li>例: <code>f.player_max_hp</code>, <code>f.next_level_exp</code></li>
</ul>
</li>
</ul>
<h4><code>[TextDisplayComponent]</code> - 声（テキスト表示）</h4>
<p>テキストオブジェクトにアタッチし、スコアや残りHPなどを数値として表示させます。神経（<code>WatchVariableComponent</code>）から「値が変わった」という信号を受け取ると、自身のテキスト内容を、指定されたテンプレートに従って自動で更新します。</p>
<p><strong>前提条件:</strong> このコンポーネントを機能させるには、同じオブジェクトに<code>WatchVariableComponent</code>もアタッチしておく必要があります。</p>
<p>アタッチすると、以下のパラメータを編集できます。</p>
<ul>
<li><strong>表示テンプレート</strong> (必須): どのようにテキストを表示するかの書式を指定します。特別なキーワード<code>{value}</code>が、神経から受け取った実際の値に自動的に置き換えられます。
<ul>
<li>例: <code>SCORE: {value}</code> → SCORE: 100</li>
<li>例: <code>HP: {value}</code> → HP: 85</li>
<li>例: <code>{value} / 100</code> → 85 / 100</li>
<li>例: <code>{value}</code> → 85</li>
</ul>
</li>
</ul>
7.3. 実践チュートリアル：動くHPバーを作ってみよう
器を準備する: アセットブラウザからHPバーの「中身」の画像（例: hp_bar_fill.png）をシーンに追加します。名前を'player_hp_bar_fill'などに変更します。
神経を繋ぐ:
player_hp_bar_fillを選択し、プロパティパネルで「Add Component」をクリックし、WatchVariableComponentを選択します。
表示された入力欄「監視する変数 (f.)」に、**f.player_hp**と入力します。
筋肉を繋ぐ:
再度「Add Component」をクリックし、今度はBarDisplayComponentを選択します。
表示された入力欄「最大値の変数 (f.)」に、**f.player_max_hp**と入力します。
（任意）背景を置く: HPバーの「枠」の画像（例: hp_bar_frame.png）をシーンに追加し、depthを調整してplayer_hp_bar_fillのすぐ後ろに配置します。
テストする: シナリオやイベントで[eval exp="f.player_hp = 50"]のようなタグを実行すると、HPバーの表示が半分になるはずです。

コンポーネントの中でも最も強力なのがStateMachineComponentです。これは、オブジェクトに**「状態」**という概念を与え、複雑なAIや振る舞いをプログラミング無しで実装するための魂です。

アタッチ: プロパティパネルのコンポーネント追加からStateMachineComponentを追加します。
編集: 「ステートマシン・エディタを開く」ボタンを押して、専用のエディタを開きます。
ステートマシンエディタの使い方

状態リスト (左ペイン): オブジェクトが取りうる「状態」（例: 待機, 追跡, 攻撃, 気絶）を管理します。「＋」ボタンで新しい状態を追加できます。
イベントフック (右ペイン上部): 選択した状態が持つ3つのライフサイクルイベントです。
onEnter (実行時): その状態になった瞬間に一度だけ実行されます。
onUpdate (更新時): その状態であり続ける間、毎フレーム実行されます。
onExit (終了時): その状態から別の状態に移る瞬間に一度だけ実行されます。
VSLエディタ (右ペイン中央): 各フックで実行されるロジックを、お馴染みのVSL（ビジュアルスクリプト）で組みます。
実践チュートリアル：近づくと逃げるキャラクターを作ってみよう

シーンにオブジェクトを2つ配置し、それぞれ名前をPlayerとScaredyCatにします。両方に物理ボディを付与します。
ScaredyCatを選択し、StateMachineComponentをアタッチしてエディタを開きます。
逃走中(Fleeing)という新しい状態を追加します。
待機状態のonUpdateフックに、以下のVSLを組みます。
[distance_check target_b="Player" distance="200"]
distance_checkのoutput_nearピンから[state_transition to="逃走中"]に接続します。
逃走中状態のonUpdateフックに、以下のVSLを組みます。
[apply_force x="'(source.x > target.x ? 1 : -1) * 0.01'" target="source"] (プレイヤーから離れる方向に力を加える)
上記ノードのoutputから[distance_check target_b="Player" distance="400"]に接続します。
distance_checkのoutput_farピンから[state_transition to="待機"]に接続します。
プレイモードで確認します。Playerが近づくとScaredyCatが逃げ出し、十分に離れると止まるはずです。


/*
アニメーションキーの命名規則:
アニメーションキーは、必ず**[プレフィックス]_[状態]_[向き]**という形式で命名しなければならない。
例: player_walk_right, slime_idle_down
（idleのように向きがないものは[プレフィックス]_[状態]）
アニメーションの対称性:
左向きのアニメーション（walk_leftなど）は作らず、右向きのアニメーション（walk_right）を**setFlipX(true)で反転させて表現する**ことを基本とする。
（左右非対称なキャラクターの場合は、AnimationControllerを少し改造して、walk_leftも個別に再生できるようにすることも可能です）
コンポーネントの依存関係:
AnimationControllerは、同じオブジェクトにPlayerControllerやNpcControllerのような、onStateChangeとonDirectionChangeイベントを発火させるコンポーネントが存在することを前提とする。*/


高度なAI設計：ステートマシンとコンポーネントの連携
Odyssey EngineのAIは、ステートマシンと複数のAI振る舞いコンポーネントを連携させることで、高度で管理しやすい設計を可能にします。

基本原則

ステートマシンは「司令塔」: どの振る舞いをすべきかを決定します。
コンポーネントは「手足」: Patrol や Chase といった具体的な振る舞いを実行します。
原則として、同時にアクティブになる「手足」は一つだけです。
連携の仕組み

連携には、[call_component_method] VSLタグと、各コンポーネントが持つ enable() / disable() メソッドを使用します。

実践ガイド：巡回(Patrol)と追跡(Chase)を切り替えるAIの作り方
まず、敵キャラクターオブジェクトに、以下のコンポーネントをアタッチします。

NpcController: 移動の基本機能を提供します。
PatrolComponent: ウェイポイントを巡回する機能。
DetectionAreaComponent: プレイヤーを検知する機能。
ChaseComponent: プレイヤーを追跡する機能。
StateMachineComponent: これら全てを制御する司令塔。
ステートマシンエディタで、最低でも以下の2つのステートを作成します。

Patrol (初期ステート)
Chase
各ステートの onEnter フックで、そのステートでアクティブになるべきコンポーネントを enable し、休むべきコンポーネントを disable します。

Patrol ステートの onEnter:

役割: パトロールを開始し、追跡は停止させる。
VSL:
code
Vsl
[call_component_method component="PatrolComponent" method="enable"]
[call_component_method component="ChaseComponent" method="disable"]
Chase ステートの onEnter:

役割: 追跡を開始し、パトロールは中断させる。
VSL:
code
Vsl
[call_component_method component="ChaseComponent" method="enable"]
[call_component_method component="PatrolComponent" method="disable"]
(注: ChaseComponent の startChasing のような、enable 以上の処理を行うメソッドを呼び出すのがより適切です)

各ステートの onUpdate で、状態が変わる「きっかけ」を監視します。

Patrol ステートの onUpdate:

役割: 索敵範囲（DetectionAreaComponent）にプレイヤーが入ったら、Chase ステートに遷移する。
実装:
敵オブジェクトに、onAreaEnter をトリガーとするイベントを作成します。（イベントエディタを使用）
そのイベントのVSLグラフで、[state_transition to="Chase"] アクションを実行します。
Chase ステートの onUpdate:

役割: 索敵範囲からプレイヤーが出たら、Patrol ステートに戻る。
実装:
敵オブジェクトに、onAreaLeave をトリガーとする別のイベントを作成します。
そのイベントのVSLグラフで、[state_transition to="Patrol"] アクションを実行します。
なぜ onUpdate ではなくイベントを使うのか？
DetectionAreaComponent が発する onAreaEnter/onAreaLeave イベントをトリガーにすることで、onUpdate で毎フレーム「プレイヤーは範囲内にいるか？」をチェックする必要がなくなり、より効率的でイベント駆動な設計になります。

この連携方法により、各コンポーネントは自分の役割に集中でき、ステートマシンはAI全体の振る舞いを視覚的に分かりやすく管理することができます。

カスタムデータ (Custom Data)
概念

カスタムデータは、ゲーム内の各オブジェクトに自由な情報を追加で持たせるための強力な仕組みです。オブジェクトの公式プロパティ（x, y, alpha など）だけでは表現しきれない、ゲーム固有の属性や状態を保存するために使用します。

例えば、「開けられた宝箱」「特定の鍵が必要なドア」「NPCの友好度」といった情報は、カスタムデータとして保存するのが理想的です。

エディタでの使い方

オブジェクトを選択し、プロパティパネルの**「カスタムデータ」**セクションを見つけます。
**「カスタムデータを追加」**ボタンを押します。
キー: 保存したいデータの名前を入力します（例: nextWaypoint）。キーは、後でコンポーネントやVSLからこのデータを参照するための「名前」になります。
値: 保存したいデータを入力します（例: waypoint_B）。値は、文字列や数値など、自由なテキストを入力できます。
エンジンでの使われ方

コンポーネント: PatrolComponent は、ウェイポイントオブジェクトの nextWaypoint というカスタムデータを読み取って、次にどこへ行くべきかを判断します。
エンジンコア: BaseGameScene は、オブジェクトに isYSortable というカスタムデータが付いているかどうかを見て、そのオブジェクトを描画順の自動ソート対象にするかを判断します。
VSL: 将来的には [get_data key="..."] のようなタグを作ることで、シナリオの流れをカスタムデータに基づいて分岐させることも可能になります。
カスタムデータを活用することで、静的なオブジェクトに動的な「意味」や「状態」を持たせることができ、ワールドのインタラクティビティを飛躍的に向上させることができます。


8. エンジンの心臓部：ゲームフローマシン
Odyssey Engine v5.10の最も重要な進化は、ゲームフローマシン (GameFlowManager) の導入です。これは、ゲーム全体の大きな流れ（タイトル画面 → ゲーム中 → ポーズメニュー → ゲームオーバーなど）を、game_flow.json という単一の設計図に基づいて管理する、エンジンの新しい「心臓部」です。
これにより、これまで SystemScene が場当たり的に行っていたシーン遷移や状態管理が、予測可能で、視覚的に分かりやすい、堅牢なシステムへと生まれ変わりました。
8.1. 基本的な考え方：「状態」と「遷移」
ゲームフローマシンは、非常にシンプルな2つの概念に基づいています。
状態 (State): ゲームが取りうる、明確に区切られた状況のことです。
例：「タイトル画面を表示している状態 (Title)」「プレイヤーがゲームをプレイしている状態 (InGame)」「ポーズメニューが開いている状態 (Paused)」
遷移 (Transition): ある「状態」から別の「状態」へ移る「きっかけ」のことです。このきっかけは、必ずイベント (Event) によって引き起こされます。
例：「START_GAME イベントが発生したら、Title 状態から InGame 状態へ遷移する」「OPEN_PAUSE_MENU イベントが発生したら、InGame 状態から Paused 状態へ遷移する」
この「状態」と「遷移」のルールをすべて記述したものが、assets/data/game_flow.json ファイルです。
8.2. 設計図：game_flow.json の構造
このJSONファイルは、ゲーム全体の流れを定義する設計図です。
code
JSON
{
  "initialState": "Title",
  "states": {
    "Title": {
      "onEnter": [
        { "type": "transitionTo", "params": { "scene": "TitleScene" } }
      ],
      "transitions": [
        { "event": "START_GAME", "to": "InGame" }
      ]
    },
    "InGame": {
      "onEnter": [ { "type": "resumeScene" } ],
      "transitions": [
        { "event": "OPEN_PAUSE_MENU", "to": "Paused" },
        { "event": "RUN_NOVEL_OVERLAY", "to": "NovelOverlay" }
      ]
    },
    "Paused": {
      "onEnter": [
        { "type": "pauseScene" },
        { "type": "openMenuOverlay", "params": { "layout": "pause_menu" } }
      ],
      "transitions": [
        { "event": "CLOSE_PAUSE_MENU", "to": "InGame", "action": { "type": "closeOverlay" } }
      ]
    },
    "NovelOverlay": {
       "onEnter": [
        { "type": "pauseScene" },
        { "type": "runNovelOverlay" }
      ],
      "transitions": [
        { "event": "END_NOVEL_OVERLAY", "to": "InGame", "action": { "type": "closeOverlay" } }
      ]
    }
  }
}
initialState: ゲーム起動時に、最初になる状態を指定します。
states: ゲームが取りうる全ての「状態」を定義します。
onEnter: その状態に入った瞬間に自動的に実行されるアクションのリストです。
例：Title 状態に入ったら、transitionTo アクションで TitleScene を表示する。
onExit: (オプション) その状態から出る瞬間に実行されるアクションのリストです。
transitions: その状態から遷移可能なルールのリストです。
event: 遷移のきっかけとなるイベント名。
to: 遷移先の状態名。
action: (オプション) 遷移が実行される瞬間に、一度だけ実行されるアクション。
8.3. アクション・リファレンス
game_flow.json の中で使える type (アクションの種類) は、エンジンの心臓部を操作するための強力な命令です。
アクション type	説明	主な使用場面
transitionTo	現在のシーンを停止し、指定された新しいシーンを開始します。最も基本的なシーン切り替えです。	Title 状態に入ったら TitleScene を表示する、など。
pauseScene	現在アクティブなゲームシーンをポーズさせます。	ポーズメニューやオーバーレイを表示する直前の onEnter で使用。
resumeScene	直前にポーズされたゲームシーンを再開します。	InGame 状態に戻る際の onEnter で使用。
openMenuOverlay	OverlayScene を起動し、指定されたレイアウトを表示させます。	Paused 状態に入ったら、pause_menu レイアウトを表示する、など。
runNovelOverlay	NovelOverlayScene を起動し、イベントから渡されたシナリオファイルを実行します。	NovelOverlay 状態に入った時に、実際のオーバーレイ処理を開始する。
closeOverlay	現在表示されているオーバーレイシーン（OverlayScene または NovelOverlayScene）を閉じます。	ポーズメニューを閉じる、またはノベルオーバーレイが終了する際の transition アクションとして使用。
stopTime	物理エンジンなど、ゲーム内時間の進行を停止します。	ポーズメニュー表示時など。
resumeTime	停止したゲーム内時間を再開します。	ゲーム復帰時など。
8.4. イベントの発行方法（プログラマー向け）
UIのボタンやシナリオタグなどからゲームフローの状態を遷移させたい場合は、EngineAPI を通じてイベントを発行します。
code
JavaScript
// UIのボタンがクリックされた時など
EngineAPI.fireGameFlowEvent('START_GAME');

// [run_scenario] タグのハンドラ内部など
// 'scenario' という追加情報を添えてイベントを発行
EngineAPI.fireGameFlowEvent('RUN_NOVEL_OVERLAY', { scenario: 'event_01.ks' });
拡張の手引き
実装方法を選択するための『5段階の思考フレームワーク』
レベル1：既存の「コンポーネント」で実現できないか？
考えること： 「この機能は、単一のオブジェクト（GameObject）の振る舞いや見た目を変えるものか？」
例：
「HPが半分以下になったら、キャラクターを点滅させたい」
→ BlinkOnDamageComponent を作る。WatchVariableComponent と同じように f.player_hp を監視し、条件を満たしたら gameObject.alpha をTweenで変化させる。
「特定のアイテムを持っていたら、このドアが開くようにしたい」
→ DoorComponent を作る。onOverlap でプレイヤーに触れられたら、StateManager に f.has_key の値を確認し、true なら開くアニメーションを再生する。
なぜ最初か？ 最も再利用性が高く、他の部分への影響が少ない、クリーンな実装方法だからです。**オブジェクト単体の話は、まずコンポーネントで考える。**これが鉄則です。
レベル2：既存の「タグ」で実現できないか？ (VSL / シナリオ)
考えること： 「この機能は、特定の**イベント（onOverlapなど）**や、物語の特定の瞬間（シナリオの特定の行）にだけ発生する、一連の演出や命令か？」
例：
「宝箱を開けたら、ファンファーレを鳴らし、アイテムGETのログを出し、宝箱のグラフィックを開いたものに差し替えたい」
→ VSLのイベントグラフで、[play_se], [eval exp="f.item_sword=true"], [anim_play] を順番に繋ぐ。あるいは、既存のタグを組み合わせた [open_treasure_box] という新しい複合タグを作る。
「ボス登場シーンで、画面を揺らし、BGMを変え、ボスを画面外からスライドインさせたい」
→ シナリオ (.ks) で [shake], [playbgm], [chara_show x=-100], [chara_move x=300 time=1000] を記述する。
なぜ2番目か？ タグは特定の状況下での「手順書」です。ゲームのコアなロジックではなく、演出的な側面が強い場合に最適です。
レベル3：新しい「マネージャークラス」が必要か？
考えること： 「この機能は、**複数のオブジェクトやシーンにまたがって、ゲーム全体で共有・管理されるべき、新しい『概念』や『システム』**か？」
例：
「クエスト（お使い）の受注、進行、完了を管理したい」
→ クエストの状態はセーブデータに記録され、どのシーンにいても確認できる必要がある。これは**QuestManager** を作るべき典型例です。NPCとの会話（タグ）や、アイテムの入手（コンポーネント）が、EngineAPI を通じて QuestManager に状態変化を報告します。
「アイテムの所持数を管理し、合成などのルールを実装したい」
→ InventoryManager を作るべきです。
なぜ3番目か？ 新しいマネージャークラスの追加は、エンジンに新しい「専門部署」を作ることであり、強力ですが設計も大掛かりになります。ゲームの根幹に関わる新しいシステムを導入する時だけに検討します。
レベル4：「ゲームフロー」で制御すべきか？
考えること： 「この機能は、ゲーム全体の『状態』が変化したことによって引き起こされる、マクロな振る舞いか？」
例：
「ワールドマップ画面からダンジョンシーンに遷移したい。そしてダンジョンをクリアしたらワールドマップに戻ってきたい」
→ game_flow.json に WorldMap と Dungeon という新しい状態を追加する。Dungeon の中で DUNGEON_CLEAR イベントが発生したら、WorldMap 状態に遷移するように定義する。
「全てのステージをクリアしたら、エンディングに遷移させたい」
→ STAGE_CLEAR イベントの transition に、condition: "sf.clear_stage_count >= 10" を追加し、Ending 状態へ遷移させる。
なぜ4番目か？ ゲームフローは、あくまで状態の遷移と、それに伴う大まかな指示を管理するものです。シーンの切り替えや、ゲームの大きなモード（プレイ中、ポーズ中など）の変更といった、極めてマクロな視点でのみ使うべきです。
レベル5：あるいは、もっと別の何か？ (コアの拡張)
考えること： 「上記4つのいずれにも当てはまらない。これは、エンジンそのものの**基本的な機能（物理、描画、入力など）**を拡張する必要があるか？」
例：
「2段ジャンプを実装したい」
→ PlayerController コンポーネントの改造で対応できる。（レベル1）
「時間を数秒巻き戻すシステムを作りたい」
→ これは難しい。プレイヤーや敵の位置、状態などを記録しておく、全く新しい**「リプレイシステム」のようなものが必要になるかもしれない。これは新しいマネージャークラス**に近い。（レベル3）
「独自のシェーダーを使って、画面全体に特殊なエフェクトをかけたい」
→ これは BaseGameScene やレンダリングパイプラインといった、エンジンのコア部分の拡張が必要になる。
なぜ最後か？ これは最も難易度が高く、エンジン全体に影響を及ぼす可能性がある「心臓手術」です。実行する前には、他の4つのレベルで本当に実現できないかを、慎重に検討する必要があります。

このマニュアルが、あなたの創造の旅の信頼できる羅針盤となることを願っています。
さあ、あなただけの物語を始めましょう！
